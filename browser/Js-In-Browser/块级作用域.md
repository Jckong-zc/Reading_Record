# 块级作用域

**JavaScript 的变量提升特性，导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷**

- 为什么 JavaScript 中会存在变量提升，变量提升带来的问题
- 如何通过块级作用域配合 let、const 修复缺陷

## 作用域

**作用域：Scope，指在程序中定义变量的区域，该位置决定了变量的生命周期**

作用域就是变量与函数的可访问范围，控制着变量和函数的可见性和生命周期

### ES6 之前的两种作用域

- **全局作用域**：全局作用域中的对象在代码的任何地方都可以访问，它们的生命周期伴随着页面的生命周期
- **函数作用域**：在函数内部定义的变量或函数，只能在函数内部使用，函数执行结束后会被销毁

### 块级作用域

块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个 {} 都可以被看作是一个块级作用域

块级作用域的代码块内部定义的变量在代码块外部是访问不到的，并且在代码块中代码执行完成后，代码块中定义的变量会被销毁

```js
let name = 'Horace';

function showName() {
  console.log(name);
  if (0) {
    let name = 'new Horace';
  }
}

showName();
```

最终输出的是全局的 name = 'Horace' 的值

## 变量提升带来的问题

### 1. 变量容易在不知不觉中被覆盖

```js
var name = 'Horace';

function showName() {
  console.log(name);
  if (0) {
    var name = 'new Horace';
  }
  console.log(name);
}

showName();
```

代码执行结果是 undefined

- 会存在两个执行上下文，全局执行上下文的变量环境中的 name = 'Horace'，showName 函数执行上下文的变量环境中的 name = undefined
- 执行到 console.log(name) 的时候优先使用函数执行上下文中的 name ，输出 undefined

### 2. 本应销毁的变量没有被销毁

```js
function loop(){
  for (var i = 0; i < 7; i++) {
  }
  console.log(i); 
}
loop();
```

i 本应在 for 循环结束之后被销毁，但是最后打印出来 i 为 7

## ES6 解决变量提升带来的缺陷

ES6 中引入 let 和 const 关键字使 JavaScript 拥有块级作用域

let 声明的变量是可以被改变的，但是不能重复声明

const 声明的变量值是不能被改变的，const 真正限定的是变量指向的那个地址不变

let 和 const 都可以生成块级作用域

```js
function varTest() {
  var x = 1;
  if (true) {
    var x = 2;  // 同样的变量!
    console.log(x);  // 2
  }
  console.log(x);  // 2
}
```

在函数执行上下文中只会生成一个变量 x，函数体内所有对 x 的赋值操作直接改变环境变量中的 x 的值，所以最后输出是 2

但是 if 块里面的声明不应该影响到块外面的变量 => 将 var 改成 let

```js
function letTest() {
  let x = 1;
  if (true) {
    let x = 2;  // 不同的变量
    console.log(x);  // 2
  }
  console.log(x);  // 1
}
```

let 支持块级作用域，最后输出 1

JavaScript 引擎在编译阶段不会把 if 块中的使用 let 声明的变量存放到变量环境中

## JavaScript 是如何支持块级作用域的

如何既支持变量提升又支持块级作用域

```js
function foo(){
  var a = 1
  let b = 2
  {
    let b = 3
    var c = 4
    let d = 5
    console.log(a) // 1
    console.log(b) // 3
  }
  console.log(b) // 2
  console.log(c) // 4
  console.log(d) // reference error
}   
foo()
```

- 编译创建函数执行上下文
  - var 声明的变量在编译阶段全部被存放到变量环境中
  - let 声明的变量在编译阶段会被存放到词法环境中
  - 函数内部的作用域中通过 let 声明的变量没有被存放到词法环境中
- 继续执行代码，变量环境中的 a 被设置为 1，词法环境中的 b 被设置为 2

![执行 foo 函数内部作用域块时的执行上下文](./执行 foo 函数内部作用域块时的执行上下文.png)

作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独区域，这个区域中的变量不影响作用域块外面的变量，在作用域外面声明了变量 b，而在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在

在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构

- 一系列复制后执行 console.log(a) ，需要在词法环境和变量环境中查找变量 a 的值，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找

  ![变量查找过程](./变量查找过程.png)

- 作用域块执行结束后，内部定义的变量从词法环境的栈顶弹出

  ![作用域执行完成示意图](./作用域执行完成示意图.png)

## 总结

块级作用域是通过词法环境的栈来实现的

变量提升是通过变量环境来实现的

两者结合让 JavaScript 引擎同时支持变量提升和块级作用域

函数只会在第一次执行的时候被编译，所以编译时变量环境和词法环境最顶层数据已经确定了

当执行到块级作用域的时候，块级作用域中通过 let 和 const 声明的变量会被追加到词法环境中，当这个块执行结束之后，追加到词法作用域的内容又会销毁掉