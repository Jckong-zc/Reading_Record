# 从输入 URL 到页面显示发生了什么？

初始：用户的输入 URL，浏览器接收 URL 的输入，判断输入的是搜索内容还是 URL 地址，如果是搜索内容，浏览器根据搜索引擎合成一个 URL，如果是不带协议的网址，浏览器会自动补全协议

> **浏览器如何知道协议？**
>
> 浏览器默认使用 HTTP 协议，并且默认 80 端口
>
> 1. 最简单的方式：如果是 HTTPS 协议的网站，会对 80 端口进行监听，将 80 端口上的返回请求重定向到 HTTPS 的 443 端口上，返回 301/302 等重定向状态码
>
> 2. 安全的方式：HTTP 协议实现了一个 HSTS 机制
>
>    HTTP Strict Transport Security，意译：HTTP严格传输安全，是一个Web安全策略机制。
>
>    返回的302报文中有这样一条
>
>    Strict-Transport-Security: max-age=31536000\r\n
>
>    其含义是强制浏览器在max-age到期之前，把所有的 HTTP 方式访问自动转换成 HTTPS 方式访问
>
>    是浏览器实现的url转换，不用每次访问两次服务器，一步到位。这样避免了302跳转80->443的中间人劫持的问题。所以之后每次访问就不会出现302了，只有第一次会出现

### 网络请求

#### 1. 构建请求

浏览器会构建请求行:

构建好后，浏览器准备发起网络请求

举例：

`GET /index.html HTTP/1.1`

#### 2. 查找强缓存

检查强缓存（不需要发送 HTTP 请求），如果命中直接使用，否则进入下一步

#### 3. 准备 IP 和端口

- DNS 解析：

  - 操作系统首先**检查本地的 hosts 文件**中是否有请求网址的映射，如果有，优先调用这个 IP 地址映射，完成解析 

  - **检查浏览器自身有没有缓存**过要解析的域名对应的 IP 地址 

     如果有，解析完成 

     如果没有，首先**找 TCP/IP 参数中设置的首选 DNS 服务器(本地 DNS 服务器)**，向本地 DNS 服务器发起**递归查询（本地 DNS 服务器代替客户端去查询）** 

  - 本地 DNS 服务器收到查询时，如果要查询的域名**包含在本地配置区域资源中**，则返回解析结果给客户机，完成域名解析 

  - **如果本地 DNS 服务器本地区域文件与缓存解析都失效**，则根据本地 DNS 服务器的设置，**采用迭代查询（本地 DNS 服务器向其他根域名服务器一个个查询）**，直至解析完成 

- 端口：如果未指明端口，HTTP 默认 80，HTTPS 默认 443

#### 4. 建立 TCP 连接

Chrome 同一域名下最多建立 6 个 TCP 连接，超过 6 个需要等待

如果不需要等待，通过三次握手和服务器建立 TCP 连接

#### 5.发送 HTTP 请求

HTTP 请求需要请求头、请求行、请求体

1. 请求头：请求方法 + 请求 URI + HTTP 协议版本
2. 请求头：一些基础信息，缓存相关的标识字段也放在里面
3. 请求体：请求需要携带的内容

#### 6. 网络响应

HTTP 请求达到服务器之后，服务器进行相应的处理，最后把数据返回给浏览器

网络相应包括响应行、响应头、响应体

1. 响应行：HTTP 协议版本 + 状态码 + 状态描述
2. 响应头：包含服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息
3. 响应体：返回给浏览器端的数据

响应完成后判断 `Connection` 字段，如果请求头或响应头中带有 `Connection: Keep-Alive`，表示建立持久化连接，TCP 连接在发送后依然保持打开状态（HTTP1.1 默认开启 Keep-Alive）

如果没有 `Connection: Keep-Alive` 字段，则四次挥手断开 TCP 连接



### 解析算法

#### 构建 DOM 树

由于浏览器无法直接理解 `HTML 字符串`，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是 `DOM 树`

#### 样式计算

- 样式表格式化：将 CSS 转换为浏览器可理解的结构 -- StyleSheet 

  在浏览器控制台能够通过 `document.styleSheets` 来查看这个最终的结构

- 样式属性标准化：有些 CSS 样式的数值不易被理解，比如 em、bold 等

- 计算 DOM 树中每个节点的具体样式

  两个规则: **继承**和**层叠**

  每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫 `UserAgent样式`

  在计算完样式之后，所有的样式值会被挂在到 `window.getComputedStyle` 当中，也就是可以通过JS来获取计算后的样式

#### 生成布局树

确定元素的位置

1. 遍历生成的 DOM 树节点，并把他们添加到`布局树中`。
2. 计算布局树节点的坐标位置。

只包含可见元素



### 渲染过程

#### 建图层树

显式合成和隐式合成

- 显式合成

  1. 拥有**层叠上下文**的节点
  2. 需要裁剪的地方

- 隐式合成

  `层叠等级低`的节点被提升为单独的图层之后，那么`所有层叠等级比它高`的节点**都会**成为一个单独的图层

  > 隐式合成可能会造成层爆炸，比如大型应用中把一个 z-index 较低的元素提升为单独图层

#### 生成绘制列表

渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划

#### 生成图块和生成位图

绘制列表准备好了之后，渲染进程的主线程会给`合成线程`发送 `commit` 消息，把绘制列表提交给合成线程

- 分块

  视口范围有限，当页面非常大的时候一次性全部绘制很浪费性能，合成线程要将图层分块，加速页面首屏显示

  浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间（首屏展示低分辨率的图片，等正常的图块内容绘制完成之后，替换图片）

- 生成位图

  合成线程会选择视口附近的**图块**，把它交给**栅格化线程池**生成位图

  生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给 `合成线程`

#### 浏览器显示内容

栅格化操作完成后，**合成线程**会生成一个绘制命令，即"DrawQuad"，并发送给浏览器进程

浏览器进程中的 `viz组件` 接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡

无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的**前缓冲区**。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**，然后系统自动将`前缓冲区`和`后缓冲区`对换位置，如此循环更新。

当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象

