# 如何保证页面文件能被完整送达浏览器

衡量 Web 页面性能时一个重要的指标叫 **FP（First Paint）**

FP：从页面加载到首次开始绘制的时长

FP 直接影响了用户的跳出率，更快的页面响应意味着更多的 PV（Page View）、更高的参与度，以及更高的转化率

影响 FP 指标中一个重要的因素就是**网络加载速度**

## 如何保证页面文件能被完整地送达浏览器？

在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错

### 1. IP：把数据包送达目的主机

数据包要在互联网上进行传输，就要符合**网际协议**（Internet Protocol，简称**IP**）标准

**计算机的地址就称为 IP 地址，访问任何网站实际上是自己的计算机向另外一台计算机请求信息。**

互联网上不同的在线设备都有唯一的地址，只要知道具体地址，就可以往这个地址发送包裹

- 举例：

  如果想要把一个数据包从主机 A 发送到主机 B，在传输之前，数据包上会被附加 上主机 B 的 IP 地址信息，方便在传输的时候寻址。并且在数据包上还会附加主机 A 自身的 IP 地址，方便主机 B 受到数据包之后可以回发信息给主机 A

  附加的这些信息会被封装进 IP 数据报首部中，IP 数据报首部包括版本、首部长度、协议、生存时间、源 IP 地址、目的 IP 地址等信息

- 数据包从主机 A 到主机 B 经历的步骤：

  - 上层将数据包交给**网络层**
  - 网络层给数据包添加 IP 首部，组装好之后交给**数据链路层**
  - 数据链路层把网络层交付下来的 IP 数据报添加首部和尾部**封装成帧**
  - 向下交给**物理层**通过物理网络将数据包传输给主机 B
  - 主机 B 的数据链路层接收到数据包进行**差错检验**，如果数据包无差错则从受到的数据包中提取出 IP 数据包交付给网络层
  - 数据包传输到主机 B 的网络层，主机 B 的网络层**拆开数据包的 IP 首部**，将数据部分交给上层使用
  - 数据包到达主机 B 的上层

### 2. UDP：把数据包送达应用程序

IP 协议是非常底层的协议，只负责把数据包传送到对方主机，但是对方主机并不知道要将数据包交给哪个程序，所以需要基于 IP 协议之上能够和应用通信的协议，最常见的是**”用户数据报协议“**，User Datagram Protocol——UDP

每一个应用程序对应一个一个端口号，端口号只具有本地意义

**IP 协议只负责把数据包发送给指定的主机，剩下的交给 UDP 根据端口号把数据包分发给正确的程序**

- UDP 的首部格式
  1. 源端口：需要对方回信时选用，不需要时可用全 0
  2. 目的端口
  3. 长度：UDP 数据报的长度，最小值是 8（只有首部）
  4. 检验和

- 重新看数据包在主机 A 和 B 之间的传输

  - 上层将数据包交付给**传输层**
  - 传输层在数据包**附加 UDP 首部**，组成 UDP 报文，**再将 UDP 报文向下交给网络层**
  - 网络层**给 UDP 数据报添加 IP 首部**，组成 IP 数据报向下交付给数据链路层
  - 数据链路层把网络层交付下来的 IP 数据报添加首部和尾部**封装成帧**
  - 向下交给**物理层**通过物理网络将数据包传输给主机 B
  - 主机 B 的数据链路层接收到数据包进行**差错检验**，如果数据包无差错则从受到的数据包中提取出 IP 数据包交付给网络层
  - 数据包传输到主机 B 的网络层，主机 B 的网络层**拆开数据包的 IP 首部**，将数据部分**交给传输层**
  - 传输层中拆开 UDP 首部，并根据 UDP 首部中的**目的端口**，把 UDP 数据报通过相应的端口**交给上层的应用程序**

  **UDP 尽最大努力交付，不保证可靠交付。**对于错误的数据包，UDP 不提供重发机制，直接丢弃当前的包，并且 UDP 在发送之后也无法知道是否能达到目的地。**UDP 不能保证数据的可靠性，但是传输速度非常快**，常用于网络直播、电影等

### 3. TCP：把数据完整地送达应用程序

UDP 不适合于数据传输可靠性要求高的应用，比如邮件等

- UDP 传输存在的问题：

  - 数据包容易丢失
  - 大文件会被拆分成多个小的数据包传输，会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装数据包还原成完整的文件

- TCP （Transmission Control Protocol）传输控制协议

  **面向连接的、可靠的（有状态、可控制）、基于字节流的传输层通信协议**

- TCP 协议的特点

  - 对于数据包丢失，TCP 提供重传机制
  - TCP 引入了数据包排序机制，可以把乱序的数据包组合成完整的文件
  - 有状态：TCP 会精确记录哪些数据发了、哪些数据被对方接收了、哪些没有收到、并保证数据包（字节流）按顺序到达，不允许半点差错
  - 可控制：当意识到丢包或者网络环境不佳，TCP 会根据情况调整行为，控制发送速度或者重传

和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

## 完整的 TCP 连接过程

建立连接、传输数据、断开连接

- 建立连接阶段

  通过三次握手建立客户端和服务器之间的连接

  客户端和服务器总共要发送三个数据包确认连接建立

  1. 客户端向服务器**发送 SYN 报文请求同步**，**客户端进入 SYN-SENT 状态**
  2. 服务器接收到连接请求报文后如果同意建立连接，则**发送确认报文 （SYN ACK）给客户端**，**服务端进入 SYN-RCVD 状态**
  3. **客户端接收到服务器端的确认后向服务器端发送确认**，连接建立，客户端进入 ESATBLISHED 状态，服务器端接收到客户端的确认后进入 ESTABLISHED 状态

- 三次握手的原因：TCP 是可靠连接，客户端和服务器端都需要确认对方的发送和接收能力

  1. 第一次握手，服务器端知道客户端具有发送的能力
  2. 第二次握手，客户端知道服务器端具有发送和接收的能力
  3. 第三次握手，服务器端知道客户端具有接收的能力

- 为什么不能两次握手？

  - 根本原因：不能确认双方接收和发送的能力
  - 如果客户端发送了连接请求，但因为网络原因，连接请求延迟没有达到服务器端，TCP 以为丢包，客户端再重传一次连接请求。
  - 数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端已经断开了，忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。
  - 而如果采用三次握手，客户端就不会向服务端发出确认，服务端由于收不到确认，就知道客户端没有要求建立连接，从而不建立该连接。

- 传输数据阶段

  在传输阶段，接收端需要对每个数据包进行确认操作，接收端在收到数据包之后要发送确认信息给发送端。

  当发送端发送数据包之后，在规定的时间内没有收到接收端确认信息，会判断为丢包并触发重传。

  大文件在传输的过程中会被拆分成很多个小的数据包，数据包到达接收端后，接收端按照 TCP 首部中的需要进行排序，保证数组组装的完整性

- 断开连接阶段

  数据传输完成之后通过四次挥手断开连接

  - 四次挥手过程

    1. 第一次挥手：**A** 主动向 **B** 发送**连接释放报文（FIN = 1，seq = u）**，u 为前面已经传送过的数据的最后一个字节的序号 +1，并停止再发送数据，**A 进入 FIN-WAIT-1（终止等待 1） 状态**

    2. 第二次挥手：**B** 收到连接释放报文后**回复确认报文**，确认号 ack = u + 1，这个报文段自己的序号是 v = u + 1（FIN 消耗了一个字节），**B** **进入 CLOSE-WAIT（关闭等待）**，**TCP 连接处于半关闭状态**

       **如果 B 发送数据，A 仍然要接收**

       **B 到 A 方向的连接并未关闭**

    3. **A** 收到来自 **B** 的确认后，**进入 FIN-WAIT-2（终止等待-2）状态**，**等待 B 的释放连接报文**

    4. 第三次挥手：若 **B** 已经没有要发送给 **A** 的数据，应用进程通知 TCP 释放连接，**B 向 A 发送连接释放报文（FIN = 1，ACK =  1， seq = w，ack = u + 1）**

       **B 进入 LAST-ACK（最后确认）状态，等待 A 的确认**

    5. 第四次挥手：**A** 收到 **B** 的连接释放报文，**发送确认报文（ACK = 1，seq = u + 1，ack = w + 1）**

       **A 进入 TIME-WAIT（时间等待）状态，等到 2MSL（最长报文段寿命）后进入 CLOSED 状态彻底关闭 TCP 连接**

       **B 收到 A 的确认报文后直接进入 CLOSE 状态**

  - 为什么要等待 2MSL？

    1. 保证 A 发送的最后一个 ACK 报文能够到达 B

       这个 ACK 报文段有可能丢失，因而使 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 未收到确认，会超时重传 FIN + ACK 报文，所以 A 能在 2MSL 时间内收到重传的 FIN + ACK 报文。

       接着 A 重传一次确认，重新启动 2MSL 计时器，A 和 B 正常进入 CLOSED 状态

       如果 A 在 TIME-WAIT 状态，也就是发送完对 B 的 FIN 报文的确认之后直接是释放连接就无法确保 B 一定收到了 A 发送的确认报文，更无法收到 B 超时重传的 FIN + ACK 报文，也不会再发送一次确认报文，这样 B 无法正常进入 CLOSED 状态

    2. 防止“已失效的连接请求报文段”出现在本连接中

       A 在发送完最后一个确认 ACK 报文之后等待 2MSL 时间后可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可以使下一个新的连接中不会出现旧的连接请求报文段

    

